#!/bin/bash

# constants
export drm_program_name="${0##*/}"
export drm_program_version="v0.2.0"

# auxiliary function to print out usage help
function drm_usage()
{
    cat <<EOF
Docker "rotating machines" manager.

Usage: ${drm_program_name} <command> [options]
   or: ${drm_program_name} --help
   or: ${drm_program_name} --version

Commands: (defaults in [brackets] after descriptions)

  help [<command>]            display help for specified command
                              [display this general help]

  buid                        create new Docker image for
                              "rotating machine"

  start                       create new Docker container

  reset                       restore configuration of custom scripts

Options:

  -h, --help                  print this help

  -v, --version               print version

  --verbose                   produce verbose output

  Each command accepts its own specific options. See command-specific
  help for more information.
EOF
}

# auxiliary function to find valid path in a list
function search_for_path()
{
  options_name=$1[@]
  options=("${!options_name}")

  for d in "${options[@]}"; do
    if [ -d "${d}" ]; then
      echo "${d}"
      break
    fi
  done
}

# parameter (default) values
drm_command=
drm_verbose=
drm_options=()
drm_path_libexec=""

# parse arguments
if echo ${1} | grep "^[a-zA-Z][a-zA-Z]*"$ > /dev/null 2> /dev/null; then
  drm_command="${1}"
  shift
  if [ "${drm_command}" == "help" ]; then
    if echo ${1} | grep "^[a-zA-Z][a-zA-Z]*"$ > /dev/null 2> /dev/null; then
      drm_options=("--help")
      drm_command="${1}"
      shift
    else
      drm_usage
      exit 0
    fi
  fi
fi
for drm_arg in "${@}"; do
  case ${drm_arg} in
    -h | --help)
      if [ "x${drm_command}" == "x" ]; then
        drm_usage
        exit 0
      fi
      ;;
    -v | --version)
      echo "${drm_program_name} ${drm_program_version}"
      exit 0
      ;;
    --verbose)
      drm_verbose=true
      ;;
  esac
  if [ ${#drm_options} -gt 0 ]; then
    drm_arg=" ${drm_arg}"
  fi
  drm_options+="${drm_arg}"
done

# check command
if [ "x${drm_command}" == "x" ]; then
  echo "${drm_program_name}: Command must be specified"
  echo
  drm_usage
  exit 1
fi

# libexecdir: /usr/local/libexec/
if [ -z "${drm_path_libexec}" ]; then
  drm_path_libexec_options=(
    "$(dirname $(dirname $(which ${0})))/usr/libexec/"
    "${HOME}/.${drm_program_name}/usr/libexec/"
    "/usr/local/libexec/${drm_program_name}/"
    "/usr/local/lib/${drm_program_name}/"
    "/usr/libexec/${drm_program_name}/"
    "/usr/lib/${drm_program_name}/"
  )
  drm_path_libexec=`search_for_path drm_path_libexec_options`
fi
if [ -z "${drm_path_libexec}" ]; then
  echo "${drm_program_name}: FATAL: Unable to find libexec directory"
  exit 1
fi
if [ "x${drm_verbose}" != "x" ]; then
  echo "${drm_program_name}: Directory path: libexec: ${drm_path_libexec}"
fi
drm_path_libexec="`(cd "${drm_path_libexec}";pwd)`"
export drm_path_libexec

# datadir: /usr/local/share/
if [ -z "${drm_path_data}" ]; then
  drm_path_data_options=(
    "$(dirname $(dirname $(which ${0})))/usr/share/"
    "${HOME}/.${drm_program_name}/usr/share/"
    "/usr/local/share/${drm_program_name}/"
    "/usr/share/${drm_program_name}/"
  )
  drm_path_data=`search_for_path drm_path_data_options`
fi
if [ -z "${drm_path_data}" ]; then
  echo "${drm_program_name}: FATAL: Unable to find data directory"
  exit 1
fi
if [ "x${drm_verbose}" != "x" ]; then
  echo "${drm_program_name}: Directory path: data: ${drm_path_data}"
fi
drm_path_data="`(cd "${drm_path_data}";pwd)`"
export drm_path_data

# export script working directory
drm_path_work="`pwd`"
if [ "x${drm_verbose}" != "x" ]; then
  echo "${drm_program_name}: Directory path: work: ${drm_path_work}"
fi
export drm_path_work

# call specified script
eval "${drm_path_libexec}/drm-${drm_command} ${drm_options}"


# vim: set ts=2 sw=2 et:


